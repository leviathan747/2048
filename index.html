<!DOCTYPE html>
<html lang="en">

<head>

  <title>2048</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta charset="UTF-8"/>
  <meta name="theme-color" content="#000" />

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
  <script type="application/javascript" src="https://unpkg.com/react@16.0.0/umd/react.production.min.js"></script>
  <script type="application/javascript" src="https://unpkg.com/react-dom@16.0.0/umd/react-dom.production.min.js"></script>
  <script type="application/javascript" src="https://unpkg.com/babel-standalone@6.26.0/babel.js"></script>

  <style>

    body {
      font: "Century Gothic", Futura, sans-serif;
      background-color: #000;
      color: #fff;
    }

    input, a {
      color: #fff;
    }

    h1 {
      font-weight: bold;
    }

    .score {
      float: right;
      font-size: 18pt;
      font-weight: bold;
    }

    .board-container {
      padding: 5px;
      background-color: #333;
      border-radius: 10px;
      margin-bottom: 20px;
    }

    .board-row {
      margin: 0 !important;
    }

    .cell {
      position: relative;
      float: left;
      width: 25%;
    }

    .cell:after {
      content: "";
      display: block;
      padding-bottom: 100%;
    }

    .cell-inner {
      position: absolute;
      width: 100%;
      height: 100%;
      padding: 5px;
    }

    .cell-content {
      width: 100%;
      height: 100%;
      border-radius: 10px;
      background-color: #666;
    }

    .cell-content::before {
      content: '';
      display: inline-block;
      height: 100%;
      vertical-align: middle;
    }

    .cell-centered {
      display: inline-block;
      width: 100%;
      vertical-align: middle;
      text-align: center;
      text-shadow: 0 0 5px #000;
    }

    .tile-0 {
      background-color: #666;
    }

    .tile-1 {
      background-color: #66ccff;
    }

    .tile-2 {
      background-color: #ffff99;
    }

    .tile-3 {
      background-color: #ff66ff;
    }

    .tile-4 {
      background-color: #ff9933;
    }

    .tile-5 {
      background-color: #00ffcc;
    }

    .tile-6 {
      background-color: #9966ff;
    }

    .tile-7 {
      background-color: #ff5050;
    }

    .tile-8 {
      background-color: #669999;
    }

    .tile-9 {
      background-color: #ffcc00;
    }

    .tile-10 {
      background-color: #3366cc;
    }

    .tile-11 {
      background-color: #9999ff;
    }

    .gray-btn {
      background-color: #333;
    }

    .gray-btn:hover {
      background-color: #555;
    }

    .red-btn {
      background-color: #f00;
    }

    .red-btn:hover {
      background-color: #faa;
    }

    .red-text {
      color: red;
    }

  </style>

</head>

<body>
  <div id="root"></div>

  <script type="text/babel">

    const rootElement = document.getElementById('root');
   
    class Cell extends React.Component {
      constructor(props) {
        super(props);
      }

      componentDidUpdate() {
        if (this.props.value > 0) {
          const digits = Math.ceil(Math.log10(this.props.value));
          if (digits >= 1 && digits <= 3) {
            fitText(this.textElement, 0.2);
          }
          else if (digits >= 4 && digits <= 6) {
            fitText(this.textElement, 0.4);
          }
          else {
            fitText(this.textElement, 0.6);
          }
        }
      }

      render() {
        const val = this.props.value != 0 ? this.props.value : '';
        const styleKey = (Math.floor(Math.log2(this.props.value)) - 1) % 11 + 1;
        let classes = `cell-content tile-${styleKey}`;
        if (this.props.firstTime) {
          classes += ' red-text';
        }
        return (
          <div className="cell"><div className="cell-inner">
            <div className={classes}>
              <div className="cell-centered" ref={el => (this.textElement = el)}>
              {val}
              </div>
            </div>
          </div></div>
        );
      }
    }

    function GameRow(props) {
      return (
        <div className="row board-row">{props.cells}</div>
      );
    }

    function PlayButton(props) {
      const classes = props.disabled ? 'btn-large gray-btn hide' : 'btn-large gray-btn';
      return (
        <input className={classes} type="submit" value="Play"/>
      );
    }

    class StopButton extends React.Component {
      constructor(props) {
        super(props);
        this.state = {intervalId: null}
      }

      componentDidMount() {
        this.setState({intervalId: setInterval(this.props.callback, this.props.interval)});
      }

      componentWillUnmount() {
        clearInterval(this.state.intervalId);
      }

      render() {
        return (
          <input className="btn-large red-btn" type="submit" value="Stop" />
        );
      }
    }

    class Game extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          size: 4,
          cells: [],
          score: 0,
          newCell: 0,
          url: '',
          autoPlayOn: false,
          autoPlayInterval: 100,
          errorMessage: ''
        }
        this.resetGame = this.resetGame.bind(this);
        this.generateCell = this.generateCell.bind(this);
        this.collapse = this.collapse.bind(this);
        this.doMove = this.doMove.bind(this);
        this.handleURLChange = this.handleURLChange.bind(this);
        this.handleAutoPlay = this.handleAutoPlay.bind(this);
        this.getAutoMove = this.getAutoMove.bind(this);
        this.handleKeypress = this.handleKeypress.bind(this);
      }

      resetGame(state) {
        state.cells = new Array(state.size * state.size);
        state.cells.fill(0);
        state.score = 0;
        return state;
      }

      generateCell(state) {
        const emptyCells = [];
        for (let i = 0; i < state.cells.length; i++ ) {
          if (state.cells[i] == 0) {
            emptyCells.push(i);
          }
        }
        state.newCell = emptyCells[Math.floor(Math.random() * emptyCells.length)]
        state.cells[state.newCell] = 2;
        return state;
      }

      collapse(row, state) {
        const len = row.length;
        row = row.filter(x => (x != 0));  // remove 0s
        for (let i = 1; i < row.length; i++) {  // combine pairs
          if (row[i-1] == row[i]) {
            row[i-1] = row[i-1] + row[i];
            row[i] = 0;
            state.score += row[i-1];
          }
        }
        row = row.filter(x => (x != 0));  // remove 0s again
        row = row.concat(new Array(len - row.length).fill(0));  // pad with 0s back to original size
        return row;
      }

      doMove(code) {
        let state = this.state;
        state.errorMessage = '';
        let cells = [];
        let colcells = []
        switch (code) {
        case 0:  // right to left
          for (let i = 0; i < state.size; i++) {
            const row = state.cells.slice(i * state.size, i * state.size + state.size);
            cells = cells.concat(this.collapse(row, state));
          }
          break;
        case 1:  // bottom to top
          for (let i = 0; i < state.size; i++) {
            const col = [];
            for (let j = 0; j < state.size; j++) {
              col.push(state.cells[j * state.size + i]);
            }
            colcells = colcells.concat(this.collapse(col, state));
          }
          for (let i = 0; i < state.size; i++) {
            for (let j = 0; j < state.size; j++) {
              cells[j * state.size + i] = colcells[i * state.size + j];
            }
          }
          break;
        case 2:  // left to right
          for (let i = 0; i < state.size; i++) {
            const row = state.cells.slice(i * state.size, i * state.size + state.size);
            cells = cells.concat(this.collapse(row.reverse(), state).reverse());
          }
          break;
        case 3:  // top to bottom
          for (let i = 0; i < state.size; i++) {
            const col = [];
            for (let j = 0; j < state.size; j++) {
              col.push(state.cells[j * state.size + i]);
            }
            colcells = colcells.concat(this.collapse(col.reverse(), state).reverse());
          }
          for (let i = 0; i < state.size; i++) {
            for (let j = 0; j < state.size; j++) {
              cells[j * state.size + i] = colcells[i * state.size + j];
            }
          }
          break;
     
        default:
          cells = state.cells;
          //state.errorMessage = `Invalid move code: ${code}`;
          console.log(`Invalid move code: ${code}`);
        }
        if (JSON.stringify(cells) != JSON.stringify(state.cells)) {
          state.cells = cells;
          state = this.generateCell(state);
        }
        this.setState(state);
      }

      handleURLChange(event) {
        const state = this.state;
        state.url = event.target.value;
        this.setState(state);
      }

      handleAutoPlay(event) {
        const state = this.state;
        state.autoPlayOn = state.autoPlayOn ? false : true;
        state.errorMessage = '';
        this.setState(state);
        event.preventDefault();
      }

      getAutoMove() {
        const game = this;
        fetch(this.state.url, {
          method: 'post',
          body: JSON.stringify({size: this.state.size, cells: this.state.cells, score: this.state.score})
        }).then(function (resp) {  
          return resp.json();
        }).then(function(data) {
          if (data != undefined && data.move != undefined && data.move >= 0 && data.move <= 3) {
            game.doMove(data.move);
          }
        })  
        .catch(function (error) {  
          const state = game.state;
          state.errorMessage = `Request failure: ${error}`;
          game.setState(state);
        });
      }

      handleKeypress(event) {
        if (event.keyCode >= 37 && event.keyCode <= 40) {
          this.doMove(event.keyCode - 37);
        }
      }

      componentDidMount() {
        let state = this.resetGame(this.state);
        state = this.generateCell(state);
        this.setState(state);
        addEventListener('keydown', this.handleKeypress);
        swipedetect(document.getElementById('gameboard'), this.doMove);
      }

      render() {
        const rows = [];
        for (let i = 0; i < this.state.size; i++) {
          const row = []
          for (let j = 0; j < this.state.size; j++) {
            const index = i * this.state.size + j;
            row.push(<Cell value={this.state.cells[index]} firstTime={this.state.newCell == index} />);
          }
          rows.push(<GameRow cells={row} />);
        }
        const game = this;
        const doReset = function() {
          let state = game.resetGame(game.state);
          state = game.generateCell(state);
          game.setState(state);
        }
        const textInputClasses = this.state.url == '' ? 'col s12' : 'col s9';
        return (
          <div className="container">
            <div className="row">
              <div className="col l6 offset-l3 s12">
                <div className="row">
                  <div className="col s12">
                    <h1>2048</h1>
                  </div>
                </div>
                <div className="row">
                  <div className="col s12">
                    <div className="btn gray-btn" onClick={doReset}>Reset</div>
                    <span className="score">Score: {this.state.score}</span>
                  </div>
                </div>
                <div id="gameboard" className="board-container">
                  {rows}
                </div>
                <div className="row">
                  <div className="col s12">
                    <form onSubmit={this.handleAutoPlay}>
                      <div className="row">
                        <div className={textInputClasses}>
                          <label>
                            Auto-play URL:
                            <input id="urlinput" type="text" value={this.state.url} onChange={this.handleURLChange} />
                          </label>
                        </div>
                        <div className="col s3">
                          {this.state.autoPlayOn ? (
                          <StopButton callback={this.getAutoMove} interval={this.state.autoPlayInterval} />
                          ) : (
                          <PlayButton disabled={this.state.url == ''}/>
                          )}
                        </div>
                      </div>
                    </form>
                  </div>
                </div>
                {this.state.errorMessage != '' ? (
                <div className="row">
                  <div className="col s12 red-text">{this.state.errorMessage}</div>
                </div>
                ) : (
                null
                )}
              </div>
            </div>
          </div>
        );
      }
    }

    ReactDOM.render(<Game/>, rootElement);

  </script>

  <script type="text/javascript">
    /*!
    * FitText.js 1.0 jQuery free version
    *
    * Copyright 2011, Dave Rupert http://daverupert.com
    * Released under the WTFPL license
    * http://sam.zoy.org/wtfpl/
    * Modified by Slawomir Kolodziej http://slawekk.info
    *
    * Date: Tue Aug 09 2011 10:45:54 GMT+0200 (CEST)
    */
    (function(){
    
      let addEvent = function (el, type, fn) {
        if (el.addEventListener)
          el.addEventListener(type, fn, false);
    		else
    			el.attachEvent('on'+type, fn);
      };
    
      let extend = function(obj,ext){
        for(let key in ext)
          if(ext.hasOwnProperty(key))
            obj[key] = ext[key];
        return obj;
      };
    
      window.fitText = function (el, kompressor, options) {
    
        let settings = extend({
          'minFontSize' : -1/0,
          'maxFontSize' : 1/0
        },options);
    
        let fit = function (el) {
          let compressor = kompressor || 1;
    
          let resizer = function () {
            el.style.fontSize = Math.max(Math.min(el.clientWidth / (compressor*10), parseFloat(settings.maxFontSize)), parseFloat(settings.minFontSize)) + 'px';
          };
    
          // Call once to set.
          resizer();
    
          // Bind events
          // If you have any js library which support Events, replace this part
          // and remove addEvent function (or use original jQuery version)
          addEvent(window, 'resize', resizer);
          addEvent(window, 'orientationchange', resizer);
        };
    
        if (el.length)
          for(let i=0; i<el.length; i++)
            fit(el[i]);
        else
          fit(el);
    
        // return set of elements
        return el;
      };
    })();
  </script>

  <script type="text/javascript">

    let threshold = 150;    // required min distance traveled to be considered swipe
    let restraint = 100;    // maximum distance allowed at the same time in perpendicular direction
    let allowedTime = 300;  // maximum time allowed to travel that distance

    // credit: http://www.javascriptkit.com/javatutors/touchevents2.shtml
    function swipedetect(touchsurface, callback) {
    
      let swipedir = undefined;
      let startX = undefined;
      let startY = undefined;
      let distX = undefined;
      let distY = undefined;
      let elapsedTime = undefined;
      let startTime = undefined;
      let handleswipe = callback || function(swipedir){};
    
      touchsurface.addEventListener('touchstart', function(e) {
        let touchobj = e.changedTouches[0];
        swipedir = -1;
        startX = touchobj.pageX;
        startY = touchobj.pageY;
        startTime = new Date().getTime();  // record time when finger first makes contact with surface
        e.preventDefault();
      }, false);
    
      touchsurface.addEventListener('touchmove', function(e) {
        e.preventDefault();  // prevent scrolling when inside DIV
      }, false);
    
      touchsurface.addEventListener('touchend', function(e) {
        let touchobj = e.changedTouches[0];
        distX = touchobj.pageX - startX;  // get horizontal dist traveled by finger while in contact with surface
        distY = touchobj.pageY - startY;  // get vertical dist traveled by finger while in contact with surface
        elapsedTime = new Date().getTime() - startTime;  // get time elapsed
        if (elapsedTime <= allowedTime) {  // first condition for swipe met
          if (Math.abs(distX) >= threshold && Math.abs(distY) <= restraint) {  // 2nd condition for horizontal swipe met
            swipedir = (distX < 0)? 0 : 2;  // if dist traveled is negative, it indicates left swipe
          }
          else if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint) {  // 2nd condition for vertical swipe met
            swipedir = (distY < 0)? 1 : 3;  // if dist traveled is negative, it indicates up swipe
          }
        }
        handleswipe(swipedir);
        e.preventDefault();
      }, false)
    }

  </script>

</body>

</html>
